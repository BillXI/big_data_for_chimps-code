require 'gorillib'
require 'gorillib/model'
require 'gorillib/array/wrap'
require 'pry'
require 'rake/file_utils.rb'

DOCKER_USER = ENV['DOCKER_USER '] || 'bd4c'

HADOOP_IMAGES = [
  'baseimage', 'hadoop_base',
  'hadoop_lounge',
  'hadoop_nn', 'hadoop_rm', 'hadoop_snn', 'hadoop_worker',
].map{|slug| "#{DOCKER_USER}/#{slug}" }

DATA_IMAGES = [
  'data_gold', 'data_outd', 'data_nn', 'data_hdfs0',
  'home_chimpy', 'volume_boxer',
].map{|slug| "#{DOCKER_USER}/#{slug}" }

ALL_IMAGES = [ 'blalor/docker-hosts', 'phusion/baseimage:0.9.15', 'busybox' ] + HADOOP_IMAGES + DATA_IMAGES

HADOOP_CONTAINERS = [
  'hadoop_lounge',
  'hadoop_nn', 'hadoop_rm', 'hadoop_snn', 'hadoop_worker',
]

DATA_CONTAINERS = {
  data_gold:   { image: 'bd4c/data_gold',    volumes: ['/data/gold'],         },
  data_outd:   { image: 'bd4c/data_outd',    volumes: ['/data/gold'],         },
  data_hdfs0:  { image: 'bd4c/data_hdfs0',   volumes: ['/bulk/hadoop/hdfs'],  },
  data_nn:     { image: 'bd4c/data_nn',      volumes: ['/bulk/hadoop/name'],  },
  home_chimpy: { image: 'bd4c/home_chimpy',  volumes: ['/home/chimpy'],  },
}

CONTAINER = ENV['ctr'] || ENV['container']
IMAGE     = ENV['img'] || ENV['img']

namespace :data do
  task(:run) do
    ctr_name = CONTAINER || 'all'
    names = DockerRunner.arg_or_all(ctr_name, DATA_CONTAINERS.keys)
    names.each do |name|
      opts = DATA_CONTAINERS[name.to_sym] or raise "Missing definition for container #{name}"
      opts = opts.merge(name: name, interactive: false, entrypoint_args: ['pushpull', opts[:volumes].first])
      opts[:ignore_errors] = true if ctr_name == 'all'
      DockerRunner.run(opts)
    end
  end
  task :create => :run
  task(:delete_data ) do
    containers = DockerRunner.arg_or_all(CONTAINER, DATA_CONTAINERS.keys)
    DockerRunner.stop(containers, ignore_errors: true)
    DockerRunner.rm(containers, ignore_errors: true)
  end
  task(:start_interactive){ DockerRunner.start(CONTAINER, interactive: true) }

  task(:inspector => 'inspector:run')
  namespace :inspector do
    task(:run) do
      DockerRunner.run(image: 'ubuntu', name: 'data_inspector', interactive: true, volumes_from: DATA_CONTAINERS.keys)
    end
    task(:delete) do
      DockerRunner.stop('data_inspector', ignore_errors: true)
      DockerRunner.rm('data_inspector', ignore_errors: true)
    end
  end
end

namespace :cluster do
  task :start do
    sh "decking start cluster"
  end

  task :stop do
    sh "decking stop cluster"
  end

  task :create do
    sh "decking create cluster"
  end

  task :kill     => [:stop, :rm_containers]

  task :restart  => [:kill, :create, :start]

  task :recycle  => ['docker:build', :kill, :create, :start]

  task :rm_containers do
    args = HADOOP_CONTAINERS
    sh "docker rm #{args.join(" ")} ; true"
  end
end

namespace :docker do

  task :make_gold_sheller do
    sh "docker run -it --name data_gold  --volume '/data/gold' bd4c/data_gold mirror /data/gold"
  end

  task :make_gold_sheller do
    sh "docker run -it --name dg_sheller --volume '/data/gold' bd4c/data_gold shell"
  end

  task :make_gold_archiver do
    sh "docker run -it --name dg_archiver --volumes-from data_gold bd4c/data_gold mirror /data/gold"
  end

  task :build do
    HADOOP_IMAGES.each do |img_name|
      banner("Building #{img_name}")
      sh("decking build #{img_name}")
    end
  end

  task :pull do
    ALL_IMAGES.each do |img_name|
      banner("Pull #{img_name} -- this can take a stupidly long time")
      sh("docker pull #{img_name}")
    end
  end

  task :push do
    (HADOOP_IMAGES + DATA_IMAGES).each do |img_name|
      banner("Push #{img_name} -- this can take a stupidly long time, and you have to be part of the bd4c org for it to work")
      sh("docker push #{img_name}")
    end
  end

  task :helpers do
    if not ENV['DOCKER_HOST']
      warn "You don't seem to have a DOCKER_HOST environment variable set -- if the next commands fail, that's why."
    end
    puts "Got DOCKER_HOST of #{ENV['DOCKER_HOST']}"
    sh "decking build #{DOCKER_USER}/deb_proxy"
    sh "decking create helpers"
    sh "decking start  helpers"
  end

  task :helpers_stop do
    sh "decking stop helpers"
  end

  task :rmi_all do
    sh "docker rmi $(docker images | grep '^<none>' | awk '{print $3}') ; true"
  end

  task :rm_stopped do
    args = `docker ps -a  | egrep -v ' Up |CONTAINER ID' | cut -c 1-12`.gsub(/[\r\n]/, " ")
    if args.empty?
      puts "No stopped containers to kill"
    else
      sh "docker rm #{args} ; true"
    end
  end

  task :df do
    sh "boot2docker ssh df -m /mnt/sda1"
  end

  task :ps do
    sh "docker ps -a"
  end

  task :images do
    lines = `docker images --no-trunc`.split(/[\r\n]+/).drop(1)
    images = lines.each_with_index.map{|line, idx| DockerImage.from_listing(line, idx) }
    images.sort_by(&:name).each{|image| puts image.to_s }
  end

  task :history do
    # feae5a29ea12 hb pre ; b52ff881a5fd bi pre db0ad19d8544
    lines = `docker history --no-trunc #{DOCKER_USER}/hadoop_base`.split(/[\r\n]+/).drop(1)
    images = lines.each_with_index.map{|line, idx| DockerImage.from_history(line, idx) }
    images.sort_by(&:name).each{|image| puts image.to_s }
  end

  task :open_ports do
    forward_ports(HADOOP_PORTS)
    forward_ports(SSH_PORTS)
    forward_ports(OTHER_PORTS)
  end
end

HUMAN_TO_BYTES = { 'GB' => 2**30, 'MB' => 2**20, 'kB' => 2**10, 'B' => 1 }
def human_to_bytes(num, units)
  raise "Can't dehumanize #{[num, units].inspect}" if not HUMAN_TO_BYTES.include?(units)
  (num.to_f * HUMAN_TO_BYTES[units]).to_i
end

class ParamList < Array
  def dasherize(name)
    name.to_s.gsub(/_/, '-')
  end
  def add_param(name, val)
    self << "--#{dasherize(name)}=#{val.to_s}" if val.present?
    self
  end
  def add_flag(str, val)
    self << str.to_s if val.present?
    self
  end
  def add_boolean(name, val)
    self << "--#{dasherize(name)}" if val.present?
    self
  end

  def add_string_params(names, opts)
    names.each{|name| add_param(name, opts[name.to_sym]) }
    self
  end
  def add_array_param(name, vals)
    Array.wrap(vals).each do |val|
      add_param(name, val)
    end
    self
  end
end


class DockerImage
  # feae5a29ea12        About an hour ago   /bin/sh -c #(nop) COPY file:bb5fb02a76c6852b8   2.091 kB
  HISTORY_RE = /^([0-9a-f]+)\s+(.*?ago)\s+(.*?)\s+([0-9\.]+) (B|kB|MB|GB)$/
  # bd4c/baseimage       latest              db0ad19d8544        58 seconds ago      713.7 MB
  LISTING_RE = /^([\w\/\-<>]+)\s+([\w\/\-\.<>]+)\s+([0-9a-f]+)\s+(.*?ago)\s+([0-9\.]+) (B|kB|MB|GB)$/
  #
  PRINTF_FORMAT = %w[%3d %-23s %-15s %10d %7s\ %2s %12s %-23s %s].join("\t")

  attr_accessor :id, :name, :tag, :sz_num, :sz_units, :ago, :cmd, :idx

  def initialize(id, name, tag, sz_num, sz_units, ago, cmd, idx=0)
    @id, @name, @tag, @sz_num, @sz_units, @ago, @cmd, @idx = [id, name, tag, sz_num, sz_units, ago, cmd, idx]
  end

  # name, tag, image id, created, virtual size
  def self.from_listing(str, idx = 0)
    name, tag, id, ago, sz_num, sz_units = str.chomp.match(LISTING_RE).captures rescue nil
    return unless sz_units
    new(id, name, tag, sz_num, sz_units, ago, '-', idx)
  end

  # image, created, command, size
  def self.from_history(str, idx = 0)
    id, ago, cmd, sz_num, sz_units = str.chomp.match(HISTORY_RE).captures rescue nil
    return unless sz_units
    new(id, '~', '~', sz_num, sz_units, ago, cmd, idx)
  end

  def short_id()   id[0..12] ; end
  def short_cmd()  cmd[0..100] ; end
  def size()       human_to_bytes(sz_num, sz_units) ; end

  def to_s
    PRINTF_FORMAT % [idx, name, tag, size, sz_num, sz_units, short_id, ago, short_cmd]
  end
end

# The hadoop ports that might potentially be interesting
HADOOP_PORTS = {
  8042 => 'nm-console', 50075 => 'dn-console', 8010 => 'dn-jmx',
  8888 => 'hue', 8088 => 'rm-console', 19888 => 'hist-server', 50070 => 'nn-console' }
# open ssh ports at 9022, 9122, 9222, etc
SSH_PORTS = {
  9022 => 'foyer-ssh', 9122 => 'worker-ssh', 9222 => 'hue-ssh', 9322 => 'rm-ssh', 9422 => 'nn-ssh',
  9522 => 'snn-ssh',   9622 => 'fiddle-ssh', 9722 => nil,      9822 => nil,
  10022 => 'deb-proxy-ssh', 10122 => nil, 10222 => nil, }
OTHER_PORTS  = { 10000 => 'deb-proxy' }

def forward_ports(ports)
  ports.each do |port, name|
    name ||= "tcp-port#{port}"
    sh "VBoxManage modifyvm boot2docker-vm --natpf1 '#{name},tcp,,#{port},,#{port}' ; true"
    sh "VBoxManage modifyvm boot2docker-vm --natpf1 '#{name},udp,,#{port},,#{port}' ; true"
  end
end

def banner(str)
  puts( "\n  " + "*"*50 + "\n  *\n" )
  puts "  * #{str}\n  *\n"
end

module DockerRunner
  extend self; # methods now callable with DockerRunner.foo as well
  def expect_one(arg, opts={})
    if arg.blank? || (arg.to_s == 'all')
      abort "Please supply a single container name with 'ctr=name' (not 'all')"
    end
    arg
  end

  def arg_or_all(container, all)
    if container.blank?
      abort "Please supply a container name with 'ctr=name', or 'ctr=all' for all relevant containers"
    end
    container = all if container == 'all'
    Array.wrap(container)
  end

  class Container
    include Gorillib::Model
    field :name,         String
    field :volumes_from, String
    field :volumes,      Array
    field :links,        Array
    field :ports,        Array
    field :exposes,      Array
    field :envs,         Array
  end

  def start(container, opts={})
    expect_one(container)
    params = ParamList.new.add_flag('-ia', opts[:interactive])
    execute(*["docker", "start", *params, container], opts)
  end

  def stop(containers, opts={})
    execute(*["docker", "stop", *Array.wrap(containers)], opts)
  end

  # remove the given containers
  # @param containers [Array] container names to remove
  def rm(containers, opts={})
    execute("docker", "rm", *Array.wrap(containers), opts)
  end

  def run(opts)
    raise(ArgumentError, "Need to supply an image: #{opts}") if opts[:image].to_s.blank?
    params = ParamList.new
    params.add_string_params([:name, :hostname, :entrypoint], opts)
    params.add_array_param('volumes-from', opts[:volumes_from])
    params.add_array_param('volume',       opts[:volumes])
    params.add_array_param('link',         opts[:links])
    params.add_array_param('publish',      opts[:ports])
    params.add_array_param('expose',       opts[:exposes])
    params.add_array_param('env',          opts[:envs])
    params.add_boolean(    'detach',       opts[:detach])
    params.add_flag(       '-it',          opts[:interactive])
    #
    params += opts[:other_flags] if opts[:other_flags].present?
    params << opts[:image]
    params += Array.wrap(opts[:entrypoint_args])
    #
    execute('docker', 'run', *params, opts)
  end

  def execute(*args, &block)
    opts = args.extract_options!
    args.map!(&:to_s)
    Rake.sh(*args) do |ok, res|
      if (not ok) && (not opts[:ignore_errors])
        abort("Command #{args.join(' ')} exited unsuccessfully (#{res.exitstatus})")
      end
    end
  end
end
