DOCKER_USER = ENV['DOCKER_USER '] || 'bd4c'

HADOOP_IMAGES = [
  'baseimage', 'hadoop_base',
  'hadoop_lounge',
  'hadoop_nn', 'hadoop_rm', 'hadoop_snn', 'hadoop_worker'
  ].map{|slug| "#{DOCKER_USER}/#{slug}" }

namespace :cluster do
  task :start do
    sh "decking start dev"
  end

  task :stop do
    sh "decking stop dev"
  end

  task :create do
    sh "decking create dev"
  end

  task :kill     => [:stop, :rm_containers]

  task :restart  => [:kill, :create, :start]

  task :recycle  => ['docker:build', :kill, :create, :start]

  task :rm_containers do
    args = `docker ps -a  | grep 'hadoop_' | egrep -v ' Up ' | cut -c 1-12`.gsub(/[\r\n]/, " ")
    if args.empty?
      puts "No stopped containers to kill"
    else
      sh "docker rm #{args} ; true"
    end
  end
end

namespace :docker do

  task :build do
    HADOOP_IMAGES.each do |img_name|
      banner("Building #{img_name}")
      sh("decking build #{img_name}")
    end
  end

  task :pull do
    HADOOP_IMAGES.each do |img_name|
      banner("Pull #{img_name} -- this can take a stupidly long time")
      sh("docker pull #{img_name}")
    end
  end

  task :push do
    HADOOP_IMAGES.each do |img_name|
      banner("Push #{img_name} -- this can take a stupidly long time, and you have to be part of the bd4c org for it to work")
      sh("docker push #{img_name}")
    end
  end

  task :helpers do
    if not ENV['DOCKER_HOST']
      warn "You don't seem to have a DOCKER_HOST environment variable set -- if the next commands fail, that's why."
    end
    puts "Got DOCKER_HOST of #{ENV['DOCKER_HOST']}"
    sh "decking build #{DOCKER_USER}/deb_proxy"
    sh "decking create helpers"
    sh "decking start  helpers"
  end

  task :helpers_stop do
    sh "decking stop helpers"
  end

  task :rmi_all do
    sh "docker rmi $(docker images | grep '^<none>' | awk '{print $3}') ; true"
  end

  task :rm_stopped do
    args = `docker ps -a  | egrep -v ' Up |CONTAINER ID' | cut -c 1-12`.gsub(/[\r\n]/, " ")
    if args.empty?
      puts "No stopped containers to kill"
    else
      sh "docker rm #{args} ; true"
    end
  end

  task :df do
    sh "boot2docker ssh df -m /mnt/sda1"
  end

  task :ps do
    sh "docker ps -a"
  end

  task :images do
    lines = `docker images --no-trunc`.split(/[\r\n]+/).drop(1)
    images = lines.each_with_index.map{|line, idx| DockerImage.from_listing(line, idx) }
    images.sort_by(&:name).each{|image| puts image.to_s }
  end

  task :history do
    # feae5a29ea12 hb pre ; b52ff881a5fd bi pre db0ad19d8544
    lines = `docker history --no-trunc #{DOCKER_USER}/hadoop_base`.split(/[\r\n]+/).drop(1)
    images = lines.each_with_index.map{|line, idx| DockerImage.from_history(line, idx) }
    images.sort_by(&:name).each{|image| puts image.to_s }
  end

  task :open_ports do
    forward_ports(HADOOP_PORTS)
    forward_ports(SSH_PORTS)
    forward_ports(OTHER_PORTS)
  end
end

HUMAN_TO_BYTES = { 'GB' => 2**30, 'MB' => 2**20, 'kB' => 2**10, 'B' => 1 }
def human_to_bytes(num, units)
  raise "Can't dehumanize #{[num, units].inspect}" if not HUMAN_TO_BYTES.include?(units)
  (num.to_f * HUMAN_TO_BYTES[units]).to_i
end

class DockerImage
  # feae5a29ea12        About an hour ago   /bin/sh -c #(nop) COPY file:bb5fb02a76c6852b8   2.091 kB
  HISTORY_RE = /^([0-9a-f]+)\s+(.*?ago)\s+(.*?)\s+([0-9\.]+) (B|kB|MB|GB)$/
  # bd4c/baseimage       latest              db0ad19d8544        58 seconds ago      713.7 MB
  LISTING_RE = /^([\w\/\-<>]+)\s+([\w\/\-\.<>]+)\s+([0-9a-f]+)\s+(.*?ago)\s+([0-9\.]+) (B|kB|MB|GB)$/
  #
  PRINTF_FORMAT = %w[%3d %-23s %-15s %10d %7s\ %2s %12s %-23s %s].join("\t")

  attr_accessor :id, :name, :tag, :sz_num, :sz_units, :ago, :cmd, :idx

  def initialize(id, name, tag, sz_num, sz_units, ago, cmd, idx=0)
    @id, @name, @tag, @sz_num, @sz_units, @ago, @cmd, @idx = [id, name, tag, sz_num, sz_units, ago, cmd, idx]
  end

  # name, tag, image id, created, virtual size
  def self.from_listing(str, idx = 0)
    name, tag, id, ago, sz_num, sz_units = str.chomp.match(LISTING_RE).captures rescue nil
    return unless sz_units
    new(id, name, tag, sz_num, sz_units, ago, '-', idx)
  end

  # image, created, command, size
  def self.from_history(str, idx = 0)
    id, ago, cmd, sz_num, sz_units = str.chomp.match(HISTORY_RE).captures rescue nil
    return unless sz_units
    new(id, '~', '~', sz_num, sz_units, ago, cmd, idx)
  end

  def short_id()   id[0..12] ; end
  def short_cmd()  cmd[0..100] ; end
  def size()       human_to_bytes(sz_num, sz_units) ; end

  def to_s
    PRINTF_FORMAT % [idx, name, tag, size, sz_num, sz_units, short_id, ago, short_cmd]
  end
end

# The hadoop ports that might potentially be interesting
HADOOP_PORTS = {
  8042 => 'nm-console', 50075 => 'dn-console', 8010 => 'dn-jmx',
  8888 => 'hue', 8088 => 'rm-console', 19888 => 'hist-server', 50070 => 'nn-console' }
# open ssh ports at 9022, 9122, 9222, etc
SSH_PORTS = {
  9022 => 'foyer-ssh', 9122 => 'worker-ssh', 9222 => 'hue-ssh', 9322 => 'rm-ssh', 9422 => 'nn-ssh',
  9522 => 'snn-ssh',   9622 => nil, 10022 => 'deb-proxy-ssh', 10122 => nil, }
OTHER_PORTS  = { 10000 => 'deb-proxy' }

def forward_ports(ports)
  ports.each do |port, name|
    name ||= "tcp-port#{port}"
    sh "VBoxManage modifyvm boot2docker-vm --natpf1 '#{name},tcp,,#{port},,#{port}' ; true"
    sh "VBoxManage modifyvm boot2docker-vm --natpf1 '#{name},udp,,#{port},,#{port}' ; true"
  end
end

def banner(str)
  puts( "\n  " + "*"*50 + "\n  *\n" )
  puts "  * #{str}\n  *\n"
end
